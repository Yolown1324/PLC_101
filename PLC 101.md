***PLC 101 - IEC 61131-3***

# 1. BLOCCHI - FUNZIONI - OPERATORI

## 1.1 Temporizzatori (Timers)

[TIA Portal Temporizzatori](https://docs.tia.siemens.cloud/r/simatic_s7_1200_manual_collection_itit_20/basic-instructions/timer-operations/timer-instructions-iec-timers)

### 1.1.1 TON – Timer On Delay

![](C:\Users\Nicolò\Documents\GitHub\PLC_101\Immagini_Lezione_PLC\TON.webp)

| Campo                                                                                                                    | Tipo | Descrizione                                                       |
| ------------------------------------------------------------------------------------------------------------------------ | ---- | ----------------------------------------------------------------- |
| IN                                                                                                                       | BOOL | Segnale di abilitazione del timer.                                |
| PT                                                                                                                       | TIME | Tempo di preset (es. `T#10s`).                                    |
| Q                                                                                                                        | BOOL | Uscita: diventa vera dopo che il tempo PT è trascorso con IN = 1. |
| ET                                                                                                                       | TIME | Tempo effettivo trascorso.                                        |
| **Descrizione:** Il TON ritarda l’attivazione dell’uscita. Se IN è attivo finché ET raggiunge PT, allora Q diventa TRUE. |      |                                                                   |

---

### 1.1.2 TOF – Timer Off Delay

![](C:\Users\Nicolò\Documents\GitHub\PLC_101\Immagini_Lezione_PLC\TOF.webp)

| Campo                                                                                                  | Tipo | Descrizione                                                            |
| ------------------------------------------------------------------------------------------------------ | ---- | ---------------------------------------------------------------------- |
| IN                                                                                                     | BOOL | Segnale di ingresso.                                                   |
| PT                                                                                                     | TIME | Tempo di mantenimento in uscita dopo che IN torna FALSE (es. `T#10s`). |
| Q                                                                                                      | BOOL | Uscita che rimane vera per PT dopo che IN è passato a 0.               |
| ET                                                                                                     | TIME | Tempo effettivo di ritardo.                                            |
| **Descrizione:** Mantiene l’uscita attiva per un tempo prestabilito dopo lo spegnimento dell’ingresso. |      |                                                                        |

---

### 1.1.3 TP – Timer Pulse

![](C:\Users\Nicolò\Documents\GitHub\PLC_101\Immagini_Lezione_PLC\TP.webp)

| Campo                                                                           | Tipo | Descrizione                                     |
| ------------------------------------------------------------------------------- | ---- | ----------------------------------------------- |
| IN                                                                              | BOOL | Impulso di attivazione (fronte di salita).      |
| PT                                                                              | TIME | Durata dell’impulso.(es. `T#10s`).              |
| Q                                                                               | BOOL | Uscita attiva per PT al fronte di salita di IN. |
| ET                                                                              | TIME | Tempo trascorso dall’attivazione.               |
| **Descrizione:** Genera un impulso temporizzato ogni volta che IN passa da 0→1. |      |                                                 |

---

### 1.1.4 TONR – Timer On Delay Retentive (Retentivo)

![](C:\Users\Nicolò\Documents\GitHub\PLC_101\Immagini_Lezione_PLC\TONR.webp)

| Campo                                                                                                                                                     | Tipo | Descrizione                                  |
| --------------------------------------------------------------------------------------------------------------------------------------------------------- | ---- | -------------------------------------------- |
| IN                                                                                                                                                        | BOOL | Segnale di conteggio/attivazione.            |
| PT                                                                                                                                                        | TIME | Tempo di preset (es. `T#10s`).               |
| Q                                                                                                                                                         | BOOL | Vero quando ET ≥ PT.                         |
| ET                                                                                                                                                        | TIME | Tempo accumulato (non azzera se IN torna 0). |
| R                                                                                                                                                         | BOOL | Reset del timer.                             |
| **Descrizione:** Simile al TON, ma conserva il valore ET anche se IN torna a 0 (fino al reset) — utile quando la temporizzazione deve essere “ritentiva”. |      |                                              |

---

## 1.2 Contatori (Counters)

[TIA Portal Contatori](https://docs.tia.siemens.cloud/r/simatic_s7_1200_manual_collection_itit_20/basic-instructions/counter-operations/counter-instructions-iec-counters)

### 1.2.1CTU – Counter Up

<img title="" src="file:///C:/Users/Nicolò/Documents/GitHub/PLC_101/Immagini_Lezione_PLC/ctu.jpg" alt="" data-align="center" width="196">

| Campo                                                                                                                     | Tipo       | Descrizione                                  |
| ------------------------------------------------------------------------------------------------------------------------- | ---------- | -------------------------------------------- |
| CU                                                                                                                        | BOOL       | Fronte di salita → incremento del contatore. |
| R                                                                                                                         | BOOL       | Reset conteggio.                             |
| PV                                                                                                                        | INT / DINT | Valore di preset.                            |
| Q                                                                                                                         | BOOL       | Uscita vera se CV ≥ PV.                      |
| CV                                                                                                                        | INT / DINT | Valore corrente del conteggio.               |
| **Descrizione:** Incrementa il conteggio ad ogni fronte di salita su CU. Quando CV raggiunge o supera PV, Q diventa TRUE. |            |                                              |

---

### 1.2.2 CTD – Counter Down

<img title="" src="file:///C:/Users/Nicolò/Documents/GitHub/PLC_101/Immagini_Lezione_PLC/ctd.jpg" alt="" data-align="center" width="195">

| Campo                                                                                                       | Tipo       | Descrizione                                  |
| ----------------------------------------------------------------------------------------------------------- | ---------- | -------------------------------------------- |
| CD                                                                                                          | BOOL       | Fronte di salita → decremento del contatore. |
| LD                                                                                                          | BOOL       | Carica il valore iniziale (PV).              |
| PV                                                                                                          | INT / DINT | Valore iniziale.                             |
| Q                                                                                                           | BOOL       | Vera se CV = 0.                              |
| CV                                                                                                          | INT / DINT | Valore attuale del conteggio.                |
| **Descrizione:** Conta verso il basso ad ogni fronte di salita su CD; quando CV arriva a 0, Q diventa TRUE. |            |                                              |

---

### 1.2.3 CTUD – Counter Up/Down

<img title="" src="file:///C:/Users/Nicolò/Documents/GitHub/PLC_101/Immagini_Lezione_PLC/ctud.jpg" alt="" data-align="center" width="220">

| Campo                                                                                                                   | Tipo       | Descrizione                   |
| ----------------------------------------------------------------------------------------------------------------------- | ---------- | ----------------------------- |
| CU                                                                                                                      | BOOL       | Conteggio verso l’alto.       |
| CD                                                                                                                      | BOOL       | Conteggio verso il basso.     |
| R                                                                                                                       | BOOL       | Reset conteggio.              |
| LD                                                                                                                      | BOOL       | Carica valore PV.             |
| PV                                                                                                                      | INT / DINT | Valore di preset.             |
| QU                                                                                                                      | BOOL       | Attivo se CV ≥ PV.            |
| QD                                                                                                                      | BOOL       | Attivo se CV ≤ 0.             |
| CV                                                                                                                      | INT / DINT | Valore attuale del conteggio. |
| **Descrizione:** Combina funzioni di contatore up e down, permettendo incremento o decremento a seconda degli ingressi. |            |                               |

---

## 1.3 Comparatori e Operatori Logici

[TIA Portal Comparatori](https://docs.tia.siemens.cloud/r/simatic_s7_1200_manual_collection_itit_20/basic-instructions/comparator-operations)

</div>

| Nome                                                                                                    | Ingressi | Tipo       | Funzione          |
| ------------------------------------------------------------------------------------------------------- | -------- | ---------- | ----------------- |
| EQ                                                                                                      | IN1, IN2 | INT / REAL | Vera se IN1 = IN2 |
| NE                                                                                                      | IN1, IN2 | INT / REAL | Vera se IN1 ≠ IN2 |
| GT                                                                                                      | IN1, IN2 | INT / REAL | Vera se IN1 > IN2 |
| GE                                                                                                      | IN1, IN2 | INT / REAL | Vera se IN1 ≥ IN2 |
| LT                                                                                                      | IN1, IN2 | INT / REAL | Vera se IN1 < IN2 |
| LE                                                                                                      | IN1, IN2 | INT / REAL | Vera se IN1 ≤ IN2 |
| **Descrizione:** Comparatori numerici standard, usati per confrontare variabili in logica di controllo. |          |            |                   |
| Operatori logici standard come AND, OR, XOR, NOT gestiscono variabili BOOL e combinazioni logiche.      |          |            |                   |

---

## 1.4 Blocchi Aritmetici

[TIA Portal Funzioni matematiche](https://docs.tia.siemens.cloud/r/simatic_s7_1200_manual_collection_itit_20/basic-instructions/math-functions/add-subtract-multiply-and-divide-instructions)

| Nome                                                                                                        | Ingressi | Uscita | Tipo       | Descrizione            |
| ----------------------------------------------------------------------------------------------------------- | -------- | ------ | ---------- | ---------------------- |
| ADD                                                                                                         | IN1, IN2 | OUT    | INT / REAL | Somma di IN1 e IN2     |
| SUB                                                                                                         | IN1, IN2 | OUT    | INT / REAL | Sottrazione: IN1 - IN2 |
| MUL                                                                                                         | IN1, IN2 | OUT    | INT / REAL | Moltiplicazione        |
| DIV                                                                                                         | IN1, IN2 | OUT    | REAL       | Divisione              |
| MOD                                                                                                         | IN1, IN2 | OUT    | INT        | Resto della divisione  |
| ABS                                                                                                         | IN       | OUT    | INT / REAL | Valore assoluto        |
| SQRT                                                                                                        | IN       | OUT    | REAL       | Radice quadrata        |
| **Descrizione:** Blocchi per operazioni aritmetiche, utili nei controlli analogici o nei calcoli ausiliari. |          |        |            |                        |

---

## 1.5 Blocchi di Memoria e Gestione Bit

### 1.5.1 SR – Set / Reset

[TIA Portal Istruzioni di base con i bit](https://docs.tia.siemens.cloud/r/simatic_s7_1200_manual_collection_itit_20/basic-instructions/bit-logic-operations/set-and-reset-instructions)

| Campo                                                             | Tipo | Descrizione           |
| ----------------------------------------------------------------- | ---- | --------------------- |
| S                                                                 | BOOL | Imposta l’uscita a 1. |
| R                                                                 | BOOL | Resetta l’uscita a 0. |
| Q                                                                 | BOOL | Uscita memorizzata.   |
| **Descrizione:** Latch logico che mantiene lo stato fino a reset. |      |                       |

---

### 1.5.2 RS – Reset / Set

| Campo                                                                    | Tipo | Descrizione           |
| ------------------------------------------------------------------------ | ---- | --------------------- |
| R                                                                        | BOOL | Reset prima di tutto. |
| S                                                                        | BOOL | Setta l’uscita a 1.   |
| Q                                                                        | BOOL | Uscita memorizzata.   |
| **Descrizione:** Variante del SR con priorità invertita tra Reset e Set. |      |                       |

---

## 1.6 Blocchi di Trigger

| Nome                                                                                                    | Ingresso | Tipo | Funzione                                     |
| ------------------------------------------------------------------------------------------------------- | -------- | ---- | -------------------------------------------- |
| R_TRIG                                                                                                  | CLK      | BOOL | Uscita TRUE solo al fronte di salita (0→1).  |
| F_TRIG                                                                                                  | CLK      | BOOL | Uscita TRUE solo al fronte di discesa (1→0). |
| **Descrizione:** Utili per rilevare cambiamenti di stato (fronti) e attivare logiche solo al passaggio. |          |      |                                              |

---

## 1.7 Blocchi di Trasferimento / Conversione

| Nome                                                                                                           | Ingressi    | Tipo            | Descrizione                           |
| -------------------------------------------------------------------------------------------------------------- | ----------- | --------------- | ------------------------------------- |
| MOV                                                                                                            | IN          | Qualunque       | Copia il valore di IN in OUT          |
| SWAP                                                                                                           | IN          | BYTE / WORD     | Inverte l’ordine dei byte             |
| INT_TO_REAL                                                                                                    | IN          | INT → REAL      | Converte intero in reale              |
| REAL_TO_INT                                                                                                    | IN          | REAL → INT      | Converte reale in intero              |
| SEL                                                                                                            | G, IN0, IN1 | BOOL, Qualunque | Se G = TRUE, OUT = IN1 altrimenti IN0 |
| **Descrizione:** Blocchi utili per gestire dati, tipi, condizioni di selezione, conversioni nei programmi PLC. |             |                 |                                       |

---

## 1.8 Blocchi di Regolazione

| Nome                                                                                                      | Ingressi                             | Tipo | Descrizione                                   |
| --------------------------------------------------------------------------------------------------------- | ------------------------------------ | ---- | --------------------------------------------- |
| PID                                                                                                       | PV, SP, Kp, Ki, Kd                   | REAL | Regolatore proporzionale-integrale-derivativo |
| LIMIT                                                                                                     | MIN, IN, MAX                         | REAL | Limita IN tra MIN e MAX                       |
| SCALE                                                                                                     | IN, IN_MIN, IN_MAX, OUT_MIN, OUT_MAX | REAL | Scala un valore da un range all’altro         |
| **Descrizione:** Utilizzati nei processi analogici o nei controlli che richiedono regolazione automatica. |                                      |      |                                               |

---

## 1.9 Blocchi per Stringhe

| Nome                                                                                                                  | Ingressi     | Tipo         | Funzione                               |
| --------------------------------------------------------------------------------------------------------------------- | ------------ | ------------ | -------------------------------------- |
| CONCAT                                                                                                                | IN1, IN2     | STRING       | Concatena due stringhe                 |
| LEN                                                                                                                   | IN           | STRING       | Restituisce la lunghezza della stringa |
| LEFT / RIGHT / MID                                                                                                    | IN, N, [LEN] | STRING / INT | Estrae porzioni di testo               |
| **Descrizione:** Utili nei programmi PLC moderni per la gestione di testi, messaggi, visualizzazioni su pannello HMI. |              |              |                                        |

---

## 🔍 Note di utilizzo

- I tipi di variabile **BOOL**, **TIME**, **INT**, **REAL**, **STRING** ecc. sono definiti dallo standard IEC 61131-3.  

- Quando vengono inseriti questi blocchi nei linguaggi PLC (LD, FBD, ST) devi collegare correttamente i tipi di variabile ai pin indicati.  
  
  ---

# 2. OPEN PLC EDITOR - GUIDA AL PROGRAMMA

## 2.1 Primo avvio

![](C:\Users\Nicolò\AppData\Roaming\marktext\images\2025-10-24-15-09-03-image.png)

All'avvio del programma si incontra la schermata comune per tutti gli ambienti di sviluppo.

Per generare un nuovo progetto con la relativa scelta di parametri: 

- **File** -> **Nuovo** o, alternativamente, sull'icona <img title="" src="file:///C:/Users/Nicolò/AppData/Roaming/marktext/images/2025-10-24-15-11-17-image.png" alt="" width="50" data-align="inline">   

- Si rende necessario selezionare una cartella di destinazione **<u>VUOTA</u>** dove verranno salvati tutti i file appartenenti al progetto sviluppato. 

Una volta selezionata la cartella apparirà un menu contestuale dove inserire: 

- Il nome del programma (Es. "Cancello_Automatico") ; 

- Il tipo di POU (Program Organization Units) ; 

- Il tipo di linguaggio tra **LD** - ladder, **ST** - testo strutturato, **FBD** - diagramma a blocchi funzionali e **SFC** - diagramma sequenziale funzionale.

![](C:\Users\Nicolò\AppData\Roaming\marktext\images\2025-10-24-15-18-18-image.png)

## 2.2 Il primo programma ladder

### 2.2.1 L'interfaccia e i diversi ambienti

In alto si trovano le 3 barre multifunzione principali: 

![](C:\Users\Nicolò\AppData\Roaming\marktext\images\2025-10-25-10-35-21-image.png)

- La prima barra viene usata per le funzioni di salvataggio, stampa, "Undo / Redo", Taglia/Copia/Incolla dagli appunti, funzione "cerca nel progetto" e infine per attivare / disattivare la modalità a schermo intero.

![](C:\Users\Nicolò\AppData\Roaming\marktext\images\2025-10-25-10-36-01-image.png)

- La seconda barra viene  utilizzata per le funzioni di **Avvio simulazione PLC**, **Generare programma per OpenPLC Runtime** ( maggiori dettagli al capitolo "**3. OPEN PLC RUNTIME - GUIDA AL PROGRAMMA**" ), **Trasferire programma al PLC** e **avviare il debug live di un plc da remoto**.

![](C:\Users\Nicolò\AppData\Roaming\marktext\images\2025-10-25-10-36-31-image.png)

- La terza barra contiene tutti i comandi necessari alla compilazione di un programma nel tipo di linguaggio selezionato precedentemente, in questo caso Ladder.
  
  Viene utilizzata per le funzioni di **Selezione oggetti**, **Spostare la vista**, **Aggiungere commenti**, **Inserire barre di alimentazione**, **Inserire relè**, **Inserire contatti**, **Creare nuove variabili**, **Creare nuovi blocchi**, **Creare nuove connessioni**. 
  
  ---
  
  **Nota** : Per inserire il tipo di blocco selezionato all'interno dell'area di progettazione è necessario selezionare il tipo di comando dalla barra (o dalla libreria) e poi cliccare all'interno dell'area di progettazione stessa per posizionarlo.
  
  ---
  
  Oltre che poter selezionare il tipo di blocco da inserire dalla barra multifunzione è possibile utilizzare anche la libreria, collocata nella parte destra dello schermo e riportata di seguito.
  
  <img title="" src="file:///C:/Users/Nicolò/AppData/Roaming/marktext/images/2025-10-25-10-53-33-image.png" alt="" width="183" data-align="center">

### 2.2.2 Variabili Globali e tempo ciclo

Una volta creato il programma si può notare che sono state create in automatico una voce di configurazione e una di risorsa : 

<img src="file:///C:/Users/Nicolò/AppData/Roaming/marktext/images/2025-10-26-17-00-59-image.png" title="" alt="" width="303">

Per cambiare queste impostazioni è sufficiente cliccare sulla dicitura " Res " per accedere al menu contestuale:

![](C:\Users\Nicolò\AppData\Roaming\marktext\images\2025-10-26-17-03-16-image.png)

La finestra principale mostrerà un **primo menu** per la creazione delle varibili globali che utilizzeremo poi nel programma, un **secondo menu** per la gestione dei programmi stessi ed un **terzo menu** per gestire le diverse istanze che potrebbero coesistere contemporaneamente.

---

- Per sapere come inserire le variabili all'interno del **primo menu** fare riferimento a "**2.3 Notazione Input & Output**".

---

Nel **secondo menu** inerente alla gestione dei programmi bisogna prestare molta attenzione al valore presente all'interno del campo " Intervallo ".

Ogni programma PLC funziona ciclicamente: viene eseguita la prima istruzione fino ad arrivare all' ultima in maniera sequenziale per poi ripartire da capo.

E' fondamentale nella scelta dell'intervallo di scansione prendere in considerazione dei parametri:

1) Il programma viene eseguito su Windows o Linux tramite OpenPLC Runtime? 
   
   Se il programma plc viene eseguito su un sistema con un OS ( e conseguente kernel ) pre-esistente allora è bene non alterare eccessivamente il tempo ciclo rispetto il valore default di 20 ms poichè ciò potrebbe comportare una serie di conflitti e portare ad una esecuzione non affidabile.

2) Il programma viene eseguito su piattaforme a basso coding ( Arduino/ESP32 ) ?
   
   Se il programma viene esportato da OpenPLC Runtime per essere caricato su di una board a basso coding ciò comporta due cose: il tempo ciclo sarà affidabile ma allo stesso tempo, data la poca potenza di calcolo di queste schede, la piattaforma sarà maggiormente suscettibile anche a minimi aumenti di carico computazionale dato dalla diminuzione del tempo di ciclo.

Per i motivi citati sopra è consigliabile prevedere un periodo di live debug immediatamente dopo al caricamento del programma per assicurarsi del normale funzionamento delle operazioni attese.

## 2.3 Notazione Input & Output

Le applicazioni PLC interagiscono con il mondo esterno tramite moduli INPUT e OUTPUT e/o protocolli di comunicazioni SCADA.

Durante la progettazione dell'applicazione PLC si rende necessario decidere quali variabili verrano usate dal programma stesso per assegnare gli indirizzi di input/output necessari.

OpenPLC utilizza la nomenclatura standard IEC 61131-3 per l'assegnazione di INPUT, OUTPUT e LOCAZIONI DI MEMORIA.

L'assegnazione avviene tramite l'utilizzo di sequenze di caratteri speciali così composte:

| /     | Pref. di locaz. | Pref. di dimensione   | Indirizzo fisico |
|:-----:| --------------- |:---------------------:|:----------------:|
| **%** | **I , Q , M**   | **X , B , W , D , L** | **X.Y**          |

### 2.3.1 Prefisso di locazione

- " **I** " = Locazione di una variabile di **<u>INPUT</u>** ;

- " **Q** " = Locazione di una variabile di **<u>OUTPUT</u>** ;

- " **M** " = Locazione di una variabile di **<u>MEMORIA</u>** .

### 2.3.2 Prefisso di dimensione

Prima di elencare i vari prefissi per indicare le allocazioni di memoria è importante ricordare la definizione di **bit** : il bit corrisponde alla più piccola unità quando si parla di misure informatiche.

Rappresenta la parte più piccola in assoluto in una informazione e può assumere solamente due valori : 0 / 1 .

- " **X** " = Dimensione pari a 1 bit ;

- " **B** " = Dimensione pari a 1 byte (8 bits) ;

- " **W** " = Dimensione pari a 1 word (16 bits) ;

- " **D** " = Dimensione pari a 1 double word (32 bits) ;

- " **L** " = Dimensione pari a 1 long word (64 bits) ;

### 2.3.3 Esempio di lettura variabile

Poniamo come esempio di voler leggere lo stato di una variabile di tipo Bool ( variabile che può assumere valore 0 / 1 ).

La dichiaraznoe seguirà la sintassi mostrata precedentemente e sarà così composta:

- **%IX0.0** = variabile di **input** all'ingresso fisico **0.0** di dimensione pari a **1 bit** (0/1) ;

- **%QX0.1** = variabile di **output** all'uscita fisica **0.1** di dimensione pari a **1 bit** (0/1) ;
  
  ---
  
  **Nota** : In OpenPLC la mappatura degli I/O è dipendente dalla piattaforma utilizzata, per maggiori dettagli in merito all'assegnazione delle stesse all'interno di OpenPLC fare riferimento al Paragrafo "**<u>3. OPEN PLC RUNTIME - GUIDA AL PROGRAMMA</u>**" .
  
  ---
  
  **Nota** : Gli indirizzi di tipo **bit** (**X**) utilizzati nel **PLC** hanno una gerarchia precisa tra le due componenti dell'indirizzo stesso:

- La parte dell'inidrizzo più a destra ha l'importanza minore e può avere un valore numerico da 0 a 7. Questo numero rappresenta una posizione in un byte.
  
  Sostanzialmente ogni cifra ( da 0 a 7 ) dopo il punto che separa le due componenti dell'indirizzo corrisponde ad un bit che può assumere un valore pari a 0 o 1.

- La parte dell'indirizzo più a sinistra ha l'importanza maggiore e può avere un valore numerico da 0 a 1023. Questi 1024 valori rappresentano i 1024 byte che a loro volta possono avere 8 bit dal singolo valore di 0/1.
  
  ---
  
  **Nota** : Le dimensioni per memorie diverse da "**X**" hanno una sola cifra nel loro indirizzo.
  
  Tali memorie non devono avere un punto che divide le due cifre e devono sopratutto essere in quantità inferiore rispetto la dotazione dela piattaforma in utilizzo
  
  ---

### 2.3.4 Esempi di indicizzazioni non valide

1. **%IX0.8** = indirizzo non valido poichè la cifra di indirizzo secondaria è <u>maggiore di 7</u> ;

2. **%QX0.0.1** = indiizzo non valido poichè la gerarchia non può essere composta da un indirizzo a 3 cifre (X.Y oppure X sono le uniche due nomenclature ammesse dal programma ) ;

3. **%IB1.1** = indirizzo non valido perchè <u>l'unico</u> con il quale è ammesso una indicizzazione composta da due cifre è l'indirizzo di tipo "**X**" .

# 3. OPEN PLC RUNTIME - GUIDA AL PROGRAMMA

# 4. Il primo programma in OpenPLC - guida passo - passo

Ora che hai imparato le basi di OpenPLC, è il momento di **mettere le mani in pasta** e scrivere un po’ di codice con **OpenPLC Editor**.  
Questo progetto è un semplice **interruttore on/off**. Ti serviranno:

- Un dispositivo con **OpenPLC Runtime** installato

- **Due pulsanti**

- **Un LED**

Prima che tu lo chieda: se stai eseguendo OpenPLC su una di quelle **schede industriali** (come **UniPi**, **PiXtend**, ecc.), potresti voler sostituire il LED con una **lampada industriale a 24V**.  
Funzionerà nello stesso identico modo.

Per iniziare, collega il tuo circuito in questo modo:

![](https://autonomylogic.com//wp-content/uploads/2022/06/first-project-wiring-transparent.png)

**Osservazioni importanti:**

- **+V** rappresenta il livello di tensione positivo del tuo dispositivo. Ad esempio, per le **schede Arduino** è solitamente **+5V**, per il **Raspberry Pi** è **+3,3V**, mentre per le **schede industriali** è **+24V**.

- **PB1** e **PB2** sono **pulsanti** (nel caso l’immagine non fosse abbastanza chiara).  
  **R1** e **R2** sono **resistenze di pull-down**: qualsiasi valore compreso tra **1KΩ e 10KΩ** andrà bene.  
  Se stai utilizzando una **scheda industriale** o una **scheda con resistenze di pull-down interne**, molto probabilmente **non avrai bisogno di R1 e R2** nel tuo circuito.  
  In tal caso puoi collegare **PB1** e **PB2** direttamente a **%IX0.0** e **%IX0.1**.

- Sulle **schede Raspberry Pi**, i **primi due ingressi** (**%IX0.0** e **%IX0.1**) sono **invertiti a livello hardware**.  
  Questo può causare problemi, poiché sembrerà che i pulsanti siano **sempre premuti**.  
  Puoi risolvere il problema **invertendo il segnale di ingresso** nel programma PLC (utilizzando contatti negati, se sai come farlo) oppure semplicemente **usando altri ingressi**, ad esempio **%IX0.2** e **%IX0.3**. ​

Inizia creando un **nuovo progetto** in **OpenPLC Editor**.  
Per farlo, ti basta cliccare su **File → New**.

![](https://autonomylogic.com//wp-content/uploads/2022/06/first-project-new-project.png)

Apparirà una finestra di salvataggio che ti permetterà di scegliere **dove salvare il tuo progetto**.  
I progetti di **OpenPLC Editor** non sono singoli file, ma **cartelle** che contengono tutti i dati del progetto.  
Non puoi salvare un progetto in una cartella che contiene già altri file.  
Crea quindi una **nuova cartella**, aprila e selezionala come **posizione di destinazione** per il tuo progetto.

Una volta scelta la posizione, **OpenPLC Editor** creerà il progetto con le **impostazioni e configurazioni predefinite**, e aprirà una nuova finestra che ti chiederà di creare un nuovo **POU**.

**POU** significa *Program Organization Unit* ed è l’unità in cui viene memorizzato tutto il codice che scriverai nel tuo progetto.  
Esistono tre tipi di POU che puoi creare:

1. **Program** – codice applicativo che combina ingressi, uscite, funzioni e blocchi funzione.

2. **Function** – codice riutilizzabile che restituisce un valore.

3. **Function Block** – codice riutilizzabile che può mantenere uno stato (istanza).

Per questo tutorial creeremo **solo un POU di tipo “Program”**.  
Inserisci quindi un **nome per il tuo programma**, assicurati che il **POU Type** sia impostato su “**program**” e che il **Language** sia “**LD**” (*Ladder Diagram*).  
Ricorda inoltre che **il nome del programma non può contenere spazi o caratteri speciali**.

![](https://autonomylogic.com//wp-content/uploads/2022/06/first-project-new-pou.png)

Quando crei un nuovo programma, **OpenPLC Editor** genera automaticamente per te una **configurazione**, una **risorsa**, un **task** e un’**istanza**.  
Questi elementi servono a indicare a **OpenPLC** **come gestire il tuo programma** (ad esempio: quando richiamare una funzione, come eseguire il ciclo operativo, ecc.).

Puoi modificare questi elementi **facendo doppio clic su “Res0”** nel **pannello di sinistra**.

![](https://autonomylogic.com//wp-content/uploads/2022/06/first-project-panel.png)

La finestra principale mostra, nella parte superiore, un **campo per l’inserimento delle variabili globali** (che ti permette di creare variabili accessibili in tutto il programma), oltre a una finestra **Tasks** e una finestra **Instances**.

Puoi creare nuovi task cliccando sul **segno “+” verde** all’interno della finestra **Tasks**.  
In questo progetto **non creeremo nuovi task**, ma potresti voler modificare l’**intervallo** del task in base all’hardware su cui stai eseguendo OpenPLC.

I programmi PLC sono **ciclici**, il che significa che:

1. Iniziano dalla **prima istruzione**;

2. Proseguono fino all’**ultima**;

3. **Attendono** un breve intervallo;

4. E **ricominciano** da capo.

Il parametro **Interval** definisce **ogni quanto tempo** il ciclo del programma viene eseguito.  
Il valore predefinito è **20 ms**, cioè il programma viene eseguito **una volta ogni 20 millisecondi**.

Se vuoi che il programma venga eseguito più spesso, puoi ridurre questo tempo.  
Tuttavia, se scegli un intervallo troppo basso (ad esempio **1 ms**), il tuo programma potrebbe **consumare il 100% della CPU** del dispositivo e comunque **non riuscire a mantenere il ciclo stabile**.

👉 👉 👉Un valore sicuro per la maggior parte delle piattaforme è **20 ms**.

- Le piattaforme con **sistemi operativi** (come Windows o Linux) sono **meno reattive** e possono comportarsi in modo imprevedibile con cicli troppo brevi, poiché il sistema operativo può interferire con la pianificazione dei cicli PLC in base alle **priorità del kernel**.

- Le piattaforme **bare metal**, come le **schede Arduino**, invece, riescono a mantenere tempi di ciclo **molto precisi** e sono **più adatte** a valori di intervallo bassi.![](https://autonomylogic.com//wp-content/uploads/2022/06/first-project-config.png)

Ora che il tuo progetto è finalmente stato creato, puoi iniziare a **disegnare il diagramma a logica Ladder**.

Fai clic sul **nome del tuo programma** nel **pannello di sinistra** per aprire l’**editor Ladder**.  
La parte **superiore** della schermata è riservata alle **variabili**, mentre la parte **centrale** viene utilizzata per il **diagramma logico**.

Cominciamo aggiungendo alcune variabili:  
clicca sul **segno “+” verde** e aggiungi **tre variabili**.

|      |        |      |           |
| ---- | ------ | ---- | --------- |
| Nome | Classe | Tipo | Posizione |
| PB1  | Local  | BOOL | %IX0.0    |
| PB2  | Local  | BOOL | %IX0.1    |
| LAMP | Local  | BOOL | %QX0.0    |

![](https://autonomylogic.com//wp-content/uploads/2022/06/first-project-variables.png)

Quello che vogliamo ottenere con questo programma è che, **ogni volta che PB1 viene premuto**, la **LAMP** si **accenda** e **rimanga accesa** **fino a quando non viene premuto PB2**.

Questo comportamento si realizza tramite un **semplice circuito di mantenimento (latch)** nella **logica Ladder**, come mostrato di seguito:

![](https://autonomylogic.com//wp-content/uploads/2022/06/first-project-circuit.png)

Per creare questo circuito nell’editor, **inizia aggiungendo la barra di alimentazione sinistra** (*left power rail*).  
Puoi farlo **cliccando sull’icona della barra di alimentazione** nella **barra degli strumenti**.

![](https://autonomylogic.com//wp-content/uploads/2022/06/first-project-rail-1.png)

Adjust the left power rail pin count to 50 – this is a reasonable number if you want to add more rungs to your program later. Add another power rail with count 50, but this time select “right power rail” on properties. Place it on the right side of your screen. This is enough for you to setup the rungs for your Ladder Diagram.

Now you can start adding your ladder elements. Add a contact by clicking on the contact button on the toolbar or by right clicking on the blank editor window and selecting Add->Contact. On the window that appears, under the “Variable” parameter, select PB1 to associate your new contact with the variable PB1.

![](https://autonomylogic.com//wp-content/uploads/2022/06/first-project-rail-1-properties.png)

Repeat the process to add two more contacts, one associated with PB2 and another associated with LAMP. For the PB2 contact, select **Negated** as the modifier. Finally, add a coil by clicking on the coil button on the toolbar or by right clicking on the blank editor window and selecting Add->coil. Associate your new coil with the LAMP variable, and add a right power rail to close the circuit. Position the components in place so that they look like this picture:

![](https://autonomylogic.com//wp-content/uploads/2022/06/first-project-items.png)

The final step is to connect all the components by dragging their extremities to form a line. Connect the left side of PB1 and LAMP contacts with the left power rail. Connect the right side of PB1 with PB2, the right side of PB2 with the LAMP coil, and the right side of the LAMP coil with the right power rail. Draw the parallel LAMP contact circuit by connecting the right side of the LAMP contact with the left side of PB2. Your final project should look like the first ladder picture on this tutorial.

This circuit initially has the LAMP powered off. When you press PB1 even for a small instant, the circuit turns the LAMP on (given that PB2 is not pressed also). Once the LAMP turns on, it bypasses the PB1 button on the circuit to turn itself on continuously even after releasing PB1. This is a nice trick in ladder logic, you can actually use outputs as contacts! Now, the only way to turn the LAMP off is by pressing PB2. Since PB2 is a negated contact, it will open the circuit once it is pressed, therefore turning off the LAMP.

Now that your project is created it is a good time to test it before uploading it to the OpenPLC Runtime. You can simulate the behavior of your program by clicking on **Start PLC Simulation** on the tool bar

![](https://autonomylogic.com//wp-content/uploads/2022/06/first-project-simulation.png)

When you click on that button your project is compiled using a similar process to the OpenPLC Runtime. If there are any errors on your program, the compilation will fail and you will be alerted about the errors on the Console panel at the bottom of the screen. If the compilation succeeds, OpenPLC Editor will then start running your code. To view your code running interactively, click on Debug instance on the left panel:

![](https://autonomylogic.com//wp-content/uploads/2022/06/first-project-inspect.png)

This will open a new window where you can see the electrical flow of your program. Lines in **green** are activated, where lines in **black** aren’t. You can force a contact or coil to be activated or deactivated by right-clicking on it and selecting either **Force True** or **Force False**. Try forcing PB1 to be true and observe the flow path to the LAMP coil. Then force PB1 back to false and verify that LAMP is still activated due to the latch circuit.

Apart from graphically viewing the electrical flow on the diagram, you can also follow up the data in each variable of your program at the Debugger panel on the right side of the screen. You can add variables to the Debugger panel by clicking on the glasses icon in front of each variable from the panel on the left. Also, by double-clicking a variable on the Debugger panel you can see a graph in real-time showing the current values of the variable. This can be really useful when your program is counting steps or manipulating data.

Finally, after you have created and tested you program, the last step is to generate your program in a format that the OpenPLC Runtime will understand. To do that, simply click on Generate program for OpenPLC Runtime on the tool bar (orange down arrow) and save the .st file on your computer. This file is your ladder logic program written in a language that OpenPLC Runtime can understand. You can later upload this file to the OpenPLC Runtime as explained on [**2.2 Uploading Programs to OpenPLC Runtime.**](https://autonomylogic.com/docs/2-2-uploading-programs-to-openplc-runtime) For bare bones platforms like the Arduino boards, you can upload your program straight from OpenPLC Editor by clicking on the Arduino icon at the top tool bar.

```arduino
    
```
